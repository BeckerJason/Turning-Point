#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  FlyEnc,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           Roll,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           LF,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LM,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           LB,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           RF,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           RM,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RB,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           FlyL,          tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           FlyR,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          Chain,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float rpm=0;
int RPMGoal=90;
int fly = 4; //flywheel
int R = 4; //Roller
int Shoot = 0;
task GetRPM()
{while(1)
{
	clearTimer(T1);
	SensorValue[FlyEnc]=0;
		wait1Msec(20);
		rpm= (-60000 / T1)*(SensorValue[FlyEnc] / 392); //Multiplied by -1 Because direction of flywheel is negative and abs takes longer for cortex to process
	}
}

task RampFly()
{
startTask(GetRPM);
while (1){
while (fly==2||fly==3)
	{
		if (rpm<(RPMGoal-2)&&motor[FlyR]<85){motor[FlyR]=motor[FlyR]+1; motor[FlyL]=motor[FlyL]+1; wait1Msec(75);}
		else if (rpm>(RPMGoal+2)&&motor[FlyR]>30){motor[FlyR]=motor[FlyR]-1; motor[FlyL]=motor[FlyL]-1;wait1Msec(75);}
		else{motor[FlyR]=motor[FlyL];}
	}
}
}


task MatchRPMGoal()

{
	startTask(GetRPM);
	int power = 0;
	int MinPower = 20;
	//rpm=0 at start so waiting for the first rpm check is not necessary
	while (1)
	{
		while (fly == 2 || fly == 3)
		{
			MinPower = RPMGoal - 40;
			if (rpm > RPMGoal) { power = MinPower; }

			else if (rpm < RPMGoal) { power = 127; }

			motor[FlyL] = power;
			motor[FlyR] = motor[FlyL];
			wait1Msec(20);
			////ERROR CALCULATION/
			rpmError = abs((TargetSpeed - CurrentSpeed));

		}
	}

}

task ShootBall()
{
	while(1)
	{
		if (Shoot == 1)
		{
			fly = 2;
			while (rpmError > 1)
			{
				if (SensorValue[BallTop] == 1) { motor[chain] = 120; }
				else { motor[chain] = 0; }
				wait1Msec(10);
			}
			while (rpmError <= 1 && SensorValue[BallTop] == 0)
			{
				motor[chain] = 120;
				wait1Msec(10);
			}
			if (SensorValue[BallTop] == 1) {Shoot = 0;) //Chain motor will now be controlled by the driver buttons and will stop if nothing is being pressed
			
		}
			else {}
}

task main()
{startTask(MatchRPMGoal);
startTask(ShootBall);
while(1)
	{
		motor[LF] = motor[LM] = motor[LB] = vexRT[Ch3] + vexRT[Ch4];
		motor[RF] = motor[RM] = motor[RB] = vexRT[Ch3] - vexRT[Ch4];

		if(fly == 4 && vexRT[Btn6U] == 0){ motor[FlyL] = 0; motor[FlyR] = 0; fly = 1;}
		else if(fly == 1 && vexRT[Btn6U] == 1){ motor[FlyL] = 90; motor[FlyR] = 90; fly = 2;}
		else if(fly == 2 && vexRT[Btn6U] == 0){ motor[FlyL] = 90; motor[FlyR] = 90; fly = 3;}
		else if(fly == 3 && vexRT[Btn6U] == 1){ motor[FlyL] = 0; motor[FlyR] = 0; fly = 4;}
		else{}

		if(R == 4 && vexRT[Btn6D] == 0){ motor[Roll] = 0; R = 1;}
		else if(R == 1 && vexRT[Btn6D] == 1){ motor[Roll] = 120; R = 2;}
		else if(R == 2 && vexRT[Btn6D] == 0){ motor[Roll] = 120; R = 3;}
		else if(R == 3 && vexRT[Btn6D] == 1){ motor[Roll] = 0; R = 4;}
		else{}

		if(vexRT[Btn5U] ==1 && Shoot == 0) { motor[Chain] = 120; } //Controls will move chain as long as Shoot = 0 (Shoot button not pressed)
		else if(vexRT[Btn5D] ==1&&Shoot==0){motor[Chain] = -120;}
		else if (Shoot==0){motor[Chain] = 0;}
		else {}

		if (vexRT[Btn7R == 1]) { Shoot = 1; }
		else if (vexRT[Btn7L == 1]) { Shoot = 0; }
		else {}
	}
}
