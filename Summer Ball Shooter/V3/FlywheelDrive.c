#pragma config(Sensor, dgtl1,  Trans,          sensorDigitalOut)
#pragma config(Sensor, dgtl2,  BallTop,        sensorDigitalIn)
#pragma config(Sensor, I2C_1,  FlyEnc,         sensorNone)
#pragma config(Motor,  port1,           Roll,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           LF,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LM,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           LB,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           RF,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           RM,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RB,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           FlyL,          tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           FlyR,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          Chain,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float rpm=0;
int RPMGoal=90;
int fly = 4; //flywheel
int R = 4; //Roller
int Tran = 4;//Transmission
int Shoot = 0;
float rpmError=0;
task GetRPM()
{while(1)
	{
		clearTimer(T1);
		SensorValue[FlyEnc]=0;
		wait1Msec(20);
		rpm= abs((60000 / time1[T1])*(SensorValue[FlyEnc] / 392)); //Multiplied by -1 Because direction of flywheel is negative and abs takes longer for cortex to process
	}
}

//task RampFly()
//{
//	startTask(GetRPM);
//	while (1){
//		while (fly==2||fly==3)
//		{
//			if (rpm<(RPMGoal-2)&&motor[FlyR]<85){motor[FlyR]=motor[FlyR]+1; motor[FlyL]=motor[FlyL]+1; wait1Msec(75);}
//			else if (rpm>(RPMGoal+2)&&motor[FlyR]>30){motor[FlyR]=motor[FlyR]-1; motor[FlyL]=motor[FlyL]-1;wait1Msec(75);}
//			else{motor[FlyR]=motor[FlyL];}
//		}
//	}
//}


task MatchRPMGoal()

{
	startTask(GetRPM);
	int power = 0;
	int MinPower = 20;
	//rpm=0 at start so waiting for the first rpm check is not necessary
	while (1)
	{
		while (fly == 2 || fly == 3)
		{
			MinPower = RPMGoal - 40;
			if (rpm > RPMGoal) { power = MinPower; }

			else if (rpm < RPMGoal) { power = 127; }

			motor[FlyL] = power;
			motor[FlyR] = motor[FlyL];
			wait1Msec(20);
			rpmError = abs((RPMGoal - rpm));

		}
	}

}

task ShootBall()
{
	while(1)
	{
		if (Shoot == 1) //when button is pressed
		{
			fly = 2;
			while (rpmError > 1) // while the dif between RPM and rpmGoal is less than 1 it can shoot
			{
				if (SensorValue[BallTop] == 1) { motor[Chain] = 120; } //roll the ball forward to shooter while it still sees it (not seeing it means that the ball is gone and was shot)
				else { motor[Chain] = 0; }		
				wait1Msec(10);
			} ///when the ball is shot the rpmerror will naturally go out of range causing this loop to stop
			while (rpmError <= 1 && SensorValue[BallTop] == 0) //rpm not in range yet and no ball waiting to be shot, roll up to see ball
			{
				motor[Chain] = 120;
				wait1Msec(10);
			}
			if (SensorValue[BallTop] == 1) {Shoot = 0;} //Chain motor will now be controlled by the driver buttons and will stop if nothing is being pressed

		}
		else {}
	}
}

task main()
{startTask(MatchRPMGoal);
	startTask(ShootBall);
	while(1)
	{
		motor[LF] = motor[LM] = motor[LB] = vexRT[Ch3] + vexRT[Ch4];
		motor[RF] = motor[RM] = motor[RB] = vexRT[Ch3] - vexRT[Ch4];

		if(fly == 4 && vexRT[Btn6U] == 0){ motor[FlyL] = 0; motor[FlyR] = 0; fly = 1;}//Flywheel
		else if(fly == 1 && vexRT[Btn6U] == 1){ motor[FlyL] = 90; motor[FlyR] = 90; fly = 2;}
		else if(fly == 2 && vexRT[Btn6U] == 0){ motor[FlyL] = 90; motor[FlyR] = 90; fly = 3;}
		else if(fly == 3 && vexRT[Btn6U] == 1){ motor[FlyL] = 0; motor[FlyR] = 0; fly = 4;}
		else{}

		if(R == 4 && vexRT[Btn6D] == 0){ motor[Roll] = 0; R = 1;} //Roller
		else if(R == 1 && vexRT[Btn6D] == 1){ motor[Roll] = 120; R = 2;}
		else if(R == 2 && vexRT[Btn6D] == 0){ motor[Roll] = 120; R = 3;}
		else if(R == 3 && vexRT[Btn6D] == 1){ motor[Roll] = 0; R = 4;}
		else{}

		if(Tran == 4 && vexRT[Btn7D] == 0){ SensorValue[Trans] = 1; Tran = 1;} //Trans
		else if(Tran == 1 && vexRT[Btn7D] == 1){ SensorValue[Trans] = 0; Tran = 2;}
		else if(Tran == 2 && vexRT[Btn7D] == 0){ SensorValue[Trans] = 0; Tran = 3;}
		else if(Tran == 3 && vexRT[Btn7D] == 1){ SensorValue[Trans] = 1; Tran = 4;}
		else{}


		if(vexRT[Btn5U] ==1 && Shoot == 0) { motor[Chain] = 120; } //Controls will move chain as long as Shoot = 0 (Shoot button not pressed)
		else if(vexRT[Btn5D] ==1&&Shoot==0){motor[Chain] = -120;}
		else if (Shoot==0){motor[Chain] = 0;}
		else {}

		if (vexRT[Btn7R] == 1) { Shoot = 1; } //Shoot ball
		else if (vexRT[Btn7L] == 1) { Shoot = 0; } //Stop Mid shot
		else {}

	}
}
