#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  Trans,          sensorDigitalOut)
#pragma config(Sensor, dgtl2,  BallTop,        sensorDigitalIn)
#pragma config(Sensor, I2C_1,  FlyEnc,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           Roll,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           LF,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LM,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           LB,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           RF,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           RM,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RB,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           FlyL,          tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           FlyR,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          Chain,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float rpm=0;
float RPMGoal=110;
int fly = 4; //flywheel
int R = 4; //Roller
int Tran = 2;//Transmission
int Shoot = 0;
float rpmError=0;
#include "LCD.c";

float calculateVelocity( tMotor port, float gear_ratio = 1.0 )
{
	return( gear_ratio * getMotorVelocity( port ) );
}

task velocityCalculate()
{
	while(1) {
		// calculate using the different methods
		rpm = calculateVelocity( port8, 1 );

		// must have a delay
		wait1Msec(25);
	}
}

/*task GetRPM()
{while(1)
{
clearTimer(T1);
SensorValue[FlyEnc]=0;
wait1Msec(20);
rpm= abs((60000.000 / time1[T1])*(SensorValue[FlyEnc] / 392.000)); //Multiplied by -1 Because direction of flywheel is negative and abs takes longer for cortex to process
}
}*/

//task RampFly()
//{
//	startTask(GetRPM);
//	while (1){
//		while (fly==2||fly==3)
//		{
//			if (rpm<(RPMGoal-2)&&motor[FlyR]<85){motor[FlyR]=motor[FlyR]+1; motor[FlyL]=motor[FlyL]+1; wait1Msec(75);}
//			else if (rpm>(RPMGoal+2)&&motor[FlyR]>30){motor[FlyR]=motor[FlyR]-1; motor[FlyL]=motor[FlyL]-1;wait1Msec(75);}
//			else{motor[FlyR]=motor[FlyL];}
//		}
//	}
//}


task MatchRPMGoal()
{
	//startTask(GetRPM);
	int power = 0;
	//rpm=0 at start so waiting for the first rpm check is not necessary
	while (1)
	{
		while (fly == 2 || fly == 3)
		{
			//MinPower = RPMGoal - (RPMGoal/2);
			//if (rpm > RPMGoal) { power = MinPower; }

			//else if (rpm < RPMGoal) { power = 127; }
			power=(1.0/187.0)*(19723.0-sqrt(275450329.0-1870000.0*RPMGoal));
			motor[FlyL] = power;
			motor[FlyR] = motor[FlyL];
			wait1Msec(40);
			rpmError = abs((RPMGoal - rpm));

		}
	}

}

task ShootBall()
{
	while(1)
	{
		if (Shoot == 1) //when button is pressed
		{
			fly = 2;

			while (SensorValue[BallTop]==1){motor[Chain] = 120;}//while ball is not seen bring up
			motor[Chain] = 0; //stop chain
			while (rpmError>2){wait1Msec(5);}//wait till rpm in range
			while (SensorValue[BallTop]==0)//while ball still in bot
			{
				while (SensorValue[BallTop]==0){motor[Chain] = 120;}//while ball is still in bot
				wait1Msec(200); //give some time to make sure ball in shot
				motor[Chain] = 0;
			}
			Shoot=0;
		}
		else{}
	}
}


task main()
{
startTask(LCDSpeed);
startTask(velocityCalculate);
startTask(MatchRPMGoal);
startTask(ShootBall);
while(1)
{
motor[LF] = motor[LM] = motor[LB] = vexRT[Ch3] + vexRT[Ch4];
motor[RF] = motor[RM] = motor[RB] = vexRT[Ch3] - vexRT[Ch4];

if(fly == 4 && vexRT[Btn6U] == 0&&Shoot==0){ motor[FlyL] = 0; motor[FlyR] = 0; fly = 1;}//Flywheel
else if(fly == 1 && vexRT[Btn6U] == 1&&Shoot==0){ fly = 2;}
else if(fly == 2 && vexRT[Btn6U] == 0){fly = 3;}
else if(fly == 3 && vexRT[Btn6U] == 1&&Shoot==0){ motor[FlyL] = 0; motor[FlyR] = 0; fly = 4;}
else{}

if(R == 4 && vexRT[Btn6D] == 0){ motor[Roll] = 0; R = 1;} //Roller
else if(R == 1 && vexRT[Btn6D] == 1){ motor[Roll] = 120; R = 2;}
else if(R == 2 && vexRT[Btn6D] == 0){ motor[Roll] = 120; R = 3;}
else if(R == 3 && vexRT[Btn6D] == 1){ motor[Roll] = 0; R = 4;}
else{}

if(Tran == 4 && vexRT[Btn7D] == 0){ SensorValue[Trans] = 1; Tran = 1;} //Trans
else if(Tran == 1 && vexRT[Btn7D] == 1){ SensorValue[Trans] = 0; Tran = 2;}
else if(Tran == 2 && vexRT[Btn7D] == 0){ SensorValue[Trans] = 0; Tran = 3;}
else if(Tran == 3 && vexRT[Btn7D] == 1){ SensorValue[Trans] = 1; Tran = 4;}
else{}


if(vexRT[Btn5U] ==1 && Shoot == 0) { motor[Chain] = 120; } //Controls will move chain as long as Shoot = 0 (Shoot button not pressed)
else if(vexRT[Btn5D] ==1&&Shoot==0){motor[Chain] = -120;}
else if (Shoot==0){motor[Chain] = 0;}
else {}

if (vexRT[Btn8R] == 1) { Shoot = 1; } //Shoot ball
else if (vexRT[Btn8L] == 1) { Shoot = 0; } //Stop Mid shot
else {}

}
}


//7R = shoot
//7D = Trans
//6D = roller
//top ir sensor =1 when no ball
